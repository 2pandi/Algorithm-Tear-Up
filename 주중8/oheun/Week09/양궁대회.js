/*
통과 여부 :
시간 :
점수 :

문제 : 
    - n발씩 돌아가면서 쏨(어-> 라)
    - 점수 계산
    - k점을 더 많은 화살 맞춘 사람이 가져감
    - a = b면 어피치가 가져 감
    - 많이 맞춰도 k점만 가져감.
    - 아무도 못 맞추면 아무도 못 가져감.
    - 이미 어피치는 화살 쐈고 라이언이 젤 점수 높게 이기려면 어떤 점수를 뺏어올까

input
    - 화살 개수 n
    - 점수 배열 info
    - 10~0 중 화살 개수 return
    - 지거나 비기면 [-1]

    - 이길거면 가장 낮은 점수 맞춘 경우
이게 뭐라는거야

우승할 방법이 있으면 length 11 

배열에 있는 놈들 다 합치면 n이다
*/

/*
    유사코드
    - n은 라이언이 쏠 수 있는 화살
    - info 10~0 까지 순서대로 담은 화살

    아이디어
    - 기댓값을 비교해봐야하나
    

    length-1? 아님 reverse


의사코드
    - index 작은 순부터 apeach의 info보다 숫자가 크다면 채용한다
    - 아 어차피 하나 밖에 못 가져간다.
    - 여러 경우의 수를 어떻게 저장하고 어떻게 추가하지?
        - 낮은 인덱스부터 요소보다 화살 개수를 많게 해서 기댓값을 비교한 후 
    - 점수 내기 방식 이용해서 score를 저장하고
    - {score : 49,
    arr : [3,14,4,3,13,0,0,0,0]}
    - 이런 객체 방식으로 저장한 다음
    - score 값이 가장 높은 애들만 뽑기.
        - 작은 점수 개수가 많도록 뽑는 건....... 어떻게........해.........?
*/

function solution(n, info) {
    // 어피치에 점수 더한 거 
    let apeach = info.map((v,i)=>{return v*(10-i)});
    // 어피치 점수
    let apeachResult = apeach.reduce((sum, curr) => {
        return sum + curr;}, 0); 
    return apeachResult;
}